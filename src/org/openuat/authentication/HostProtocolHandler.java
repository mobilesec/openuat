/* Copyright Rene Mayrhofer
 * File created 2005-09
 * Modified to use UACAP based on MA-DH starting 2008-01-28
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */
package org.openuat.authentication;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.security.SecureRandom;
import java.util.Hashtable;

import net.mypapit.java.StringTokenizer;

import org.openuat.authentication.exceptions.*;
import org.openuat.util.Hash;
import org.openuat.util.LineReaderWriter;
import org.openuat.util.ProtocolCommandHandler;
import org.openuat.util.RemoteConnection;
import org.openuat.util.SafetyBeltTimer;

import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Hex;
import org.apache.log4j.Logger;

/** This class handles the key agreement protocol between two hosts on a stream
 * level. It implements both sides of the protocol, allowing to handle incoming
 * connections (i.e. incoming authentication requests) as well as initiating
 * outgoing connections (i.e. outgoing authentication requests). Events are
 * raised upon authentication success, failure and during the progress of an
 * authentication protocol. <br>
 * 
 * The protocol is called UACAP (unified auxiliary channel authentication 
 * protocol) and is based on the MANA IV family of multi-channel authentication
 * protocols as specified in [Sven Laur and Kaisa Nyberg: "Efﬁcient Mutual Data 
 * Authentication Using Manually Authenticated Strings: Extended Version"],
 * specifically the MA-DH variant. However, it additionally implements an
 * optional commitment-based exchange instead of just producing an out-of-band
 * message from the key material for the <b>input</b> type authentication as
 * explained below. This optional exchange is based on the MANA III protocol
 * presented earlier and a variant proposed by Wong and Stajano. <br>
 * 
 * This class has a dual interface and can thus be used in two different ways: 
 * either by driving the steps in the protocol from an outside caller on the 
 * instantiated object (henceforth referred to as the PlainObject style) or by 
 * registering an out-of-band channel that is subsequently used by 
 * HostProtocolHandler to handle the complete protocol run (hanceforth referred 
 * to as the Hollywood style, cf. http://c2.com/cgi/wiki?HollywoodPrinciple). 
 * The PlainObject style is more flexible, as all steps "outside" the basic 
 * crypto protocol can be handled in any way, and is used by instantiating the 
 * object with the "basic" constructor.
 * The Hollywood style can be easier to use, making the whole authentication
 * protocol a black box by reducing it to a single method call, and can be used
 * when an object implementing the OOBChannel interface is conveniently
 * available. In this case, instantiate the object by passing the 
 * AuxiliaryChannel object to the constructor.
 * In both cases, the object will fire usual authentication events for any 
 * outside listener. <br>
 * 
 * TODO: This explanation needs to be updated to actually be true...
 * 
 * The simplest possible case to use the ManaIV class for authentication is to
 * instantiate it, Hollywood style, with an existing OOBChannel object and to 
 * let it run the key agreement:
 * <pre>
 * ManaIV m = new ManaIV(myOobChannel, true);
 * m.addAuthenticationProgressHandler(myself);
 * m.authenticate(); // this method returns immediately
 * // ... wait for AuthenticationSuccess event and use the embedded key 
 * </pre>
 * Alternatively, it may e.g. be used for the heavy crypto lifting, but 
 * out-of-band message transfer is handled in a custom way, PlainObject style:
 * ManaIV m1 = new ManaIV(true);
 * byte[] msg = m1.getOobMessage();
 * // transfer msg to the remote side in a secure way
 * // on the other side:
 * m2.addOobMessage(msg);
 * 
 * The authentication success event generated by this protocol will return a 
 * RemoteConnection object for the remote parameter and an Object array as the 
 * result parameter. This object array will always have at least 3 objects: two 
 * byte arrays representing the session key and the out-of-band message for
 * <b>transfer</b> or <b>comparison</b> verification, and a String representing
 * the optional parameter that might have been specified by the client or which 
 * might have been passed to the protocol when in client mode. This third 
 * object in the object array can be null if no parameter was specified, but it 
 * will always be there. For <b>input</b> type authentication, the second 
 * object (the out-of-band message) will be null because authentication will
 * have already happened at this stage. For the other two types, the first 
 * object (the session key) may only be used <b>after</b> successful (mutual)
 * verification of the out-of-band message.
 * An optional fourth object will be included with the array when the 
 * keepSocketConnected flag was set. This fourth paramater will then contain 
 * the still connected channel object. <br>
 * 
 * If, in addition to UACAP, the server part of this HostProtocolHandler 
 * should support other commands, then custom handlers can be registered with 
 * addProtocolCommandHandlers. These commands can subsequently be handled at 
 * the stage when the Protocol_AuthenticationRequest command would be expected.
 * 
 * TODO: signal to event listeners if the other side has been human-verified
 * (in case of unidirectional OOB channels) 
 * 
 * TODO: rename out-of-band to auxiliary channel
 * 
 * @author Rene Mayrhofer
 * @version 2.0, changes to 1.0: The performProtocol method has been 
 *               significantly improved and is now based upon a generalized
 *               MA-DH protocol (which includes at least one additional
 * 				 commitment message but may add more) instead of simple and
 * 				 potentially (depending on future uses of this class) insecure
 *  			 Diffie-Hellman-only key exchange.
 * @version 1.1, changes to 1.0: Support registering additional protocol 
 *               handlers that are called for their registered protocol.
 */
public class HostProtocolHandler extends AuthenticationEventSender {
	/** Our primary logger. */
	private static Logger logger = Logger.getLogger("org.openuat.authentication.HostProtocolHandler" /*HostProtocolHandler.class*/);

	/** The byte length to use for keys, random nonces, and hashes. */ 
	private static final int NonceByteLength = 16;

	/** These are the messages of the ASCII authentication protocol. */
    public static final String Protocol_Hello = "HELO OpenUAT Authentication";
    /** This is the protocol and version string to identify which protocol we 
     * expect. May be changed for future improvements. */
	public final static String ProtocolTypeMaDH = "UACAP-1.0";

    /** @see #Protocol_Hello */
    public static final String Protocol_AuthenticationRequest = "AUTHREQ ";
    /** This is an optional field in the authentication request line, where the
     * client can pass parameters to the next authentication protocol.
     * @see #Protocol_AuthenticationRequest */
    public static final String Protocol_AuthenticationRequest_Param = "PARAM";
    /** @see #Protocol_Hello */
    public static final String Protocol_AuthenticationAcknowledge = "AUTHACK ";
    /** @see #Protocol_Hello */
    public static final String Protocol_AuthenticationAcknowledge2 = "AUTHACK2 ";

    public static final String Protocol_AuthenticationInputCommit = "AUTHINPCOM ";

    public static final String Protocol_AuthenticationInputOpen = "AUTHINPOPEN ";


    /** At the moment, the whole protocol consists of 5 stages. */
    public static final int AuthenticationStages = 5;
    
	/** If set to true, the JSSE will be used, if set to false, the Bouncycastle Lightweight API. */
	protected boolean useJSSE;
	
	/** If != -1 and the protocol has been running for longer than this, it will be aborted. */
	protected int timeoutMs = -1;
	
    /** The (already opened) connection used to communicate with the remote end, for both incoming and outgoing connections. */
    protected RemoteConnection connection;
    /** If set to false, connection will be closed after the protocol finished. 
     * @see #connection
     * @see #HostProtocolHandler(RemoteConnection, boolean, boolean)
     */
    protected boolean keepConnected;
    /** An optional parameter that can be passed from the client to the server
     * in its authentication request message. If not null, this message will be
     * forwarded by both the server and the client in their respective authentication
     * success messages.
     */
    protected String optionalParameter = null;
    /** The stream to send messages to the remote end. */
    protected OutputStreamWriter toRemote;
    /** The stream to receive messages from the remote end. */
    protected InputStream fromRemote;

    /** If defined, then this protocol drives the overall authentication in 
     * Hollywood style and can automatically select optional protocol steps
     * based on the properties of this channel.
     */
//    protected OOBChannel oobChannel = null;

    /** If this is set, then we have some form of user input that has been
     * created _before_ starting the protocol instance and is assumed to be
     * secret.
     */
    protected byte[] presharedShortSecret = null;

    /** There may be additional handlers to call, depending on the first line
     * that is received from the other side. Keys are of type String and 
     * specify the first word (command) that a handler reacts to, values are
     * of type ProtocolCommandHandler.
     */
    private Hashtable protocolCommandHandlers = null;
    
    /** This constructor should only be used by HostServerBase for incoming
	 * connections or with the static startAuthenticatingWith method for
	 * outgoing connections. It constructs the protocol in PlainObject style
	 * for <b>transfer</b> or <b>comparison</b> verification. The out-of-band
	 * message will be emitted via the AuthenticationSuccess message and the
	 * caller is responsible for using an appropriate auxiliary channel for
	 * key verification <b>before</b> using the session key.
	 * 
	 * @param con
	 *            The RemoteConnection to use for communication. It must already be
	 *            connected to the other side, but will be shut down and closed
	 *            before the protocol handler methods return, depending on the
	 *            parameter keepConnected. The reason for this asymmetry (the 
	 *            connection must be connected by the caller, but is closed by 
	 *            the methods of this class) lies in the asynchronity: the 
	 *            protocol handler methods are called in background threads 
	 *            and must therefore dispose the objects before exiting.
	 *
	 * @param timeoutMs
	 * 			  The maximum duration in milliseconds that this authentication
	 * 			  protocol may take before it will abort with an AuthenticationFailed
	 * 			  exception. Set to -1 to disable the timeout.
	 *            
	 * @param keepConnected
	 *            If set to true, the opened connection con is passed to the
	 *            authentication success event (in the results parameter) for 
	 *            further re-use of the connection (e.g. passing additional 
	 *            information about further protocol steps). If set to false, the
	 *            socket will be closed when this protocol is done with it.
	 *
	 * @param useJSSE If set to true, the JSSE API with the default JCE provider of the JVM will be used
	 *                for cryptographic operations. If set to false, an internal copy of the Bouncycastle
	 *                Lightweight API classes will be used.
	 */
    public HostProtocolHandler(RemoteConnection con, int timeoutMs, 
    		boolean keepConnected, boolean useJSSE) {
		this.connection = con;
		this.keepConnected = keepConnected;
		this.useJSSE = useJSSE;
		this.timeoutMs = timeoutMs;
    }

    /** This constructor should only be used by HostServerBase for incoming
	 * connections or with the static startAuthenticatingWith method for
	 * outgoing connections. It constructs the protocol in PlainObject style
	 * for <b>secret input</b> verification. The user input must must already
	 * have been entered and <b>must</b> remain secret until AuthenticationSuccess
	 * (or failure) is emitted and <b>must not</b> be re-used.
	 * 
	 * @param presharedShortSecret The secret, shared key entered by the user
	 *        on both sides before any interaction takes place on the wireless
	 *        channel. This <b>must</b> remain secret until the protocol finishes
	 *        and <b>must not</b> be re-used.
	 */
    public HostProtocolHandler(RemoteConnection con, byte[] presharedShortSecret, int timeoutMs, 
    		boolean keepConnected, boolean useJSSE) {
    	this(con, timeoutMs, keepConnected, useJSSE);
    	this.presharedShortSecret = presharedShortSecret;
    }

/*    public HostProtocolHandler(OOBChannel oobChannel, RemoteConnection con, int timeoutMs, 
    		boolean keepConnected, boolean useJSSE) {
    	this(con, timeoutMs, keepConnected, useJSSE);
    	this.oobChannel = oobChannel;
    }*/
    
    /** Adds a protocol command handler.
     * 
     * @param command The command to react to.
     * @param handler The handler that will be called to handle the protocol 
     *                session when it is started with command.
     */
    public void addProtocolCommandHandler(String command, ProtocolCommandHandler handler) {
    	if (protocolCommandHandlers == null)
    		protocolCommandHandlers = new Hashtable();
    	protocolCommandHandlers.put(command, handler);
    }
    
    /** Removes a protocol command handler.
     * 
     * @param command The command to stop reacting to.
     * @return true if the command handler was removed, false otherwise (if
     *         no handler was previously registered for this command).
     */
    public boolean removeProtocolCommandHandler(String command) {
    	if (protocolCommandHandlers == null)
    		return false;
    	boolean removed = (protocolCommandHandlers.remove(command) != null);
    	if (protocolCommandHandlers.size() == 0)
    		protocolCommandHandlers = null;
    	return removed;
    }
    
    /** Set the list of registered protocol command handlers, if none has 
     * been registered so far. This should only be used for initialization 
     * and will not do anything if any listener has been registered before.
     * @param handlers The list of command handlers to use. Keys <b>must</b>
     *                 be of type String, while values <b>must</b> be of type
     *                 ProtocolCommandHandler.
     * @return true if the list was set, false otherwise (when any listener has
     *         been registered before, the list will not be overwritten).
     */ 
    public void setProtocolCommandHandlers(Hashtable handlers) {
    	if (protocolCommandHandlers == null) 
    		protocolCommandHandlers = handlers;
    	else
    		logger.error("Not overwriting already initialized list of protocol command handlers");
    }
    
    /** Helper method used for closing the streams connected to the socket
	 * cleanly. 
	 * 
	 * @see #fromRemote
	 * @see #toRemote
	 */
    void shutdownStreamsCleanly() {
    	logger.debug("Shutting down streams");
    	try {
    		if (fromRemote != null)
    			fromRemote.close();
    		if (toRemote != null) {
    			toRemote.flush();
    			toRemote.close();
    		}
   		}
   		catch (IOException e) {
   			// need to ignore here, nothing we can do about it...
   			logger.error("Unable to close streams cleanly", e);
   		}
    }
    
    /** Helper method used for closing the connection cleanly. Calls 
	 * shutdownStreamsCleanly beforehand.
	 *
	 * @see #shutdownStreamsCleanly()
	 * @see #connection
	 */
    void shutdownConnectionCleanly() {
    	shutdownStreamsCleanly();
    	logger.debug("Shutting down sockets");
   		connection.close();
    }
    
    /** Simple helper function for reading a line from the remote. */
    protected String readLine() throws IOException {
    	return LineReaderWriter.readLine(fromRemote, timeoutMs);
    }
    
    /** Simple helper function for writing a line to the remote. */
    protected void println(String line) throws IOException {
    	LineReaderWriter.println(toRemote, line);
    }
    
    /** Tries to receive a properly formatted line from the remote host.
	 * If the line could not be received (i.e. no line at all or starting with 
	 * an unexpected command), an AuthenticaionFailure event is raised.
	 * 
	 * @param expectedMsg
	 *            Gives the message that is expected to be received.
	 * @param remote
	 *            The remote socket. This is only needed for raising events
	 *            and is passed unmodified to the event method.
	 * @param allowOtherCommands
	 * 			  If true, then protocolCommandHandlers are checked when the
	 *            received word does not match expectedMsg.
	 *            
	 * @return The complete parameter line on success, null otherwise.
	 */
    protected String getLine(String expectedMsg, RemoteConnection remote, boolean allowOtherCommands) throws IOException {
    	String msg = readLine();
    	if (msg == null) {
        	logger.warn("helper_getAuthenticationParamLine called with null argument");
            raiseAuthenticationFailureEvent(remote, null, "Protocol error: no message received");
            return null;
        }

        // try to extract the remote key from it
        if (!msg.startsWith(expectedMsg)) {
        	logger.debug("Received non-standard command line '" + msg + "'");
        	if (protocolCommandHandlers != null && allowOtherCommands) {
        		// we have registered handlers, maybe one can deal with the first word
        		String command = msg;
        		int firstSpace = msg.indexOf(' ');
        		if (firstSpace > 0)
        			command = msg.substring(0, firstSpace);
        		logger.debug("Checking " + protocolCommandHandlers.size() + 
        				" registered protocol command handlers for '" + command + "'");
        		if (protocolCommandHandlers.containsKey(command)) {
        			logger.debug("Command handler is known, calling it");
        			// yes, a handler is known, delegate here
        			if (! ((ProtocolCommandHandler) protocolCommandHandlers.get(command)).handleProtocol(
        					msg, remote)) {
        				logger.error("Could not handle protocol command '" + command + 
        						"', registered handler returned error");
        			}
        		}
        		else
        			logger.debug("No command handler known, ignoring and aborting protocol run");
        		// already handled in here, stop processing
        		return null;
        	}

        	logger.warn("Protocol error: unkown message '" + msg + "'");
            println("Protocol error: unknown message: '" + msg + "'");
            raiseAuthenticationFailureEvent(remote, null, "Protocol error: unknown message");
            return null;
        }

        return msg;
    }
    
	/** Tries to decode properly formatted Strings and numbers from the 
	 * protocol line. If decoding fails, an AuthenticationFailure event is 
	 * raised.
     * 
     * @param line
     * 	          The complete line from the remote, including the command
     *            prefix.
	 * @param expectedMsg
	 *            Gives the message that is expected to be received. This is
	 *            simply cut off because we assume getLine already checked for
	 *            this string to be present.
	 * @param remote
	 *            The remote socket. This is only needed for raising events
	 *            and is passed unmodified to the event method.
	 * @param isHexNumber
	 * 			  This array both determines the number of parameters to
	 * 			  try to decode and which of the parameters should be further
	 * 			  decoded from String objects to Hex-coded integers.
	 * @param expectedParts
	 *            If != null, then this array may contain parameters that are
	 *            expected to be a equal to the constant string passed in here.
	 *            All null elements are ignored.
	 * @param numMandatoryParms
	 *            The number of parameters that _must_ be found in line after
	 *            expectedMsg. It may be less than isHexNumber.length.
	 * 
	 * @return The extracted parts are returned in this array, strings (i.e.
	 *         non-number objects) as String objects, decoded numbers as byte
	 *         arrays. If decoding failed, null will be returned instead of 
	 *         the (meaningless) parts that might have been decoded.
	 * @throws IOException
	 */
    public Object[] parseLine(String line, String expectedMsg,
    		boolean[] isHexNumber, String[] expectedParts, 
    		int numMandatoryParms,
    		RemoteConnection remote) throws IOException {
    	if (line == null)
    		return null;
    	
    	// start parsing after the expected message
    	String rem = line.substring(expectedMsg.length());
    	// and go through tokens until we are out of them...
    	StringTokenizer t = new StringTokenizer(rem);
    	
    	Object[] ret = new Object[isHexNumber.length];
    	int i=0; 
    	while (i<isHexNumber.length && t.hasMoreTokens()) {
    		String elem = t.nextToken();
    		
    		// do we expect a constant here?
    		if (expectedParts != null && expectedParts.length > i &&
    			expectedParts[i] != null) {
    			if (!elem.equals(expectedParts[i])) {
    	    		String err = "Protocol error: did not find expected string at position " +
    	    				i + " after expected message '" + expectedMsg + 
    	    				", element text was '" + elem + 
    	    				"', while looking for '" + expectedParts[i] + "'"; 
    	    		logger.warn(err);
    	    		println(err);
    	    		raiseAuthenticationFailureEvent(remote, null, err);
    	    		return null;
    			}
    		}
    		else if (isHexNumber[i]) {
    	        try {
    	        	ret[i] = Hex.decodeHex(elem.toCharArray());
    	        }
    	        catch (DecoderException e) {
    	    		String err = "Protocol error: could not decode Hex number at position " +
    	    				i + " after expected message '" + expectedMsg + 
    	    				", element text was '" + elem + 
    	    				"', decoding exception: " + e.toString(); 
    	    		logger.warn(err);
    	    		println(err);
    	    		raiseAuthenticationFailureEvent(remote, e, err);
    	            return null;
    	        }
    		}
    		else {
    			ret[i] = elem;
    		}
    		i++;
    	}
    	if (i < numMandatoryParms) {
    		String err = "Protocol error: received less parameters than expected (" +
    				i + " instead of at least " + numMandatoryParms + 
    				") after expected message '" + expectedMsg + "'"; 
            logger.warn(err);
            println(err);
            raiseAuthenticationFailureEvent(remote, null, err);
            return null;
    	}
        return ret;
    }

	/** This method implements the simplest possible commitment scheme for
	 * public Diffie-Hellman keys: a hash value on the key. There is no 
	 * security proof for this scheme yet, as discussed in the original
	 * Mana IV article:
	 * 
	 * Practical implementations [ZJC06,WUS06] of the MA–DH protocol use 
	 * c = H(g^a) and such a relaxed security proof would bridge the gap 
	 * between theory and practice.
	 * 
	 * The current implementation uses SHA256-double for the commitment.
     *
     * Other options for implementing the commitment scheme according to the
     * Mana IV article are:
     * 
     * In reality, a cryptographic hash functions like SHA-1 are used instead 
     * of commitments, as such constructions are hundred times faster and there 
     * are no setup assumptions. Let H be a collision resistant hash function. 
     * Then the hash commitment is computed as (c, d) := Com(x, r) with 
     * c = H(x||r) and d = (x, r) or, as in HMAC, c = H(r ⊕ opad||H(r ⊕ ipad||x)) 
     * with d = r. Both constructions are a priori not hiding. We would like to 
     * have a provably secure construction. In theory, we could use one-wayness 
     * of H and define commitment with hard-core bits but this leads to large 
     * commitments. Instead, we use Bellare-Rogaway random oracle design 
     * principle to heuristically argue that a hash commitment based on the 
     * OAEP padding is a better alternative. Recall that the OAEP padding is 
     * c = H(s, t), s = (x||0^k0 ) XOR g(r), t = r XOR f(s). The corresponding 
     * commitment c along with d = r is provably hiding and binding if g is 
     * pseudorandom, f is random oracle, and H is collision resistant. A priori 
     * SHA-1 and SHA-512 are not known to be non-malleable, as it has never 
     * been a design goal. On the other hand, the security proof of OAEP shows 
     * CCA2 security (non-malleability) provided that H is a partial-domain 
     * one-way permutation.
     *
	 * @param ownPublicKey This side's public key for MA-DH.
	 * @return
	 * @throws InternalApplicationException 
	 */
	protected byte[] commitment(byte[] ownPublicKey) throws InternalApplicationException {
		return Hash.doubleSHA256(ownPublicKey, useJSSE);
	}
	
	/** This method implements the keyed hash function for computing the 
	 * l-Bit out-of-band message. It uses the standard HMAC-SHA256 
	 * construction.
	 */
	protected byte[] keyedHash(byte[] oobInput, byte[] oobKey) throws InternalApplicationException {
		return Hash.hmacSHA256(oobInput, oobKey, useJSSE);
	}
    
    /** This method depends on prior initialization and assumes to be launched
	 * in an independent thread, i.e. it performs blocking operations. It
	 * assumes that the socket variable already contains a valid, connected
	 * socket that can be used for communication with the remote authentication
	 * partner. fromRemote and toRemote will be initialized as streams connected
	 * to this socket.
	 * 
	 * @param serverSide
	 *            true for server side ("authenticator"), false for client side
	 *            ("authenticatee")
	 */
/*    protected void performAuthenticationProtocol(boolean serverSide) {
            byte[] remotePubKey = null;
            if (serverSide) {
            	String paramLine = helper_getLine(Protocol_AuthenticationRequest, connection, true);
                remotePubKey = helper_extractPublicKey(paramLine, Protocol_AuthenticationRequest, connection);
                if (remotePubKey == null) {
                    shutdownConnectionCleanly();
                    return;
                }
                int optParamOff = paramLine.indexOf(Protocol_AuthenticationRequest_Param);
                if (optParamOff != -1) {
                	optionalParameter = paramLine.substring(optParamOff + Protocol_AuthenticationRequest_Param.length());
                	if (logger.isDebugEnabled())
                		logger.debug("Received optional parameter from client: '" + optionalParameter + "'.");
                }
               	totalTransferTime += System.currentTimeMillis()-timestamp;
            }
            else {
            	// now send my first message, but already need the public key for it
            	ka = new SimpleKeyAgreement(useJSSE);
            	String myPubKey = new String(Hex.encodeHex(ka.getPublicKey()));
               	totalCryptoTime += System.currentTimeMillis()-timestamp;
               	timestamp = System.currentTimeMillis();
            	println(Protocol_AuthenticationRequest + myPubKey +
            			(optionalParameter != null ? " " + Protocol_AuthenticationRequest_Param + optionalParameter : ""));
               	totalTransferTime += System.currentTimeMillis()-timestamp;
            }
            raiseAuthenticationProgressEvent(connection, 2, AuthenticationStages, inOrOut + " authentication connection, " + clientToServer + " public key");

           	timestamp = System.currentTimeMillis();
            if (serverSide) {
                // for performance reasons: only now start the DH phase
            	ka = new SimpleKeyAgreement(useJSSE);
            	String myPubKey = new String(Hex.encodeHex(ka.getPublicKey()));
               	totalCryptoTime += System.currentTimeMillis()-timestamp;
               	timestamp = System.currentTimeMillis();
            	println(Protocol_AuthenticationAcknowledge + myPubKey);
               	totalTransferTime += System.currentTimeMillis()-timestamp;
            }
            else {
            	remotePubKey = helper_extractPublicKey(
            			helper_getLine(Protocol_AuthenticationAcknowledge, connection, false),
                		Protocol_AuthenticationAcknowledge, connection);
                if (remotePubKey == null)
                {
                    shutdownConnectionCleanly();
                    return;
                }
               	totalTransferTime += System.currentTimeMillis()-timestamp;
            }
            raiseAuthenticationProgressEvent(connection, 3, AuthenticationStages, inOrOut + " authentication connection, " + serverToClient + " public key");

           	timestamp = System.currentTimeMillis();
            ka.addRemotePublicKey(remotePubKey);
            Object sessKey = ka.getSessionKey();
            Object authKey = ka.getAuthenticationKey();
           	totalCryptoTime += System.currentTimeMillis()-timestamp;
            raiseAuthenticationProgressEvent(connection, 4, AuthenticationStages, inOrOut + " authentication connection, computed shared secret");
*/
	
	/** MANA-IV:
	 * 1. Alice computes (c, d) := Com_pk(ka) for random ka and sends (ma, c) 
	 *    to Bob.
	 * 2. Bob chooses random kb and sends (mb, kb) to Alice.
	 * 3. Alice sends d to Bob, who computes ka = Open_pk(c, d) and halts if 
	 *    ka = empty.
     * Both parties compute a test value oob = h(ma || mb, ka, kb) from the 
     * received messages.
	 * 4. Both parties accept (ma, mb) iff the local l-bit test values ooba 
	 *    and oobb coincide.
     *
     * Speciﬁcation: h is a keyed hash function with sub-keys ka, kb from a 
     * message space of commitment scheme. The hash function h and the public 
     * parameters pk of the commitment scheme are ﬁxed and distributed by a 
     * trusted authority.
	 */

	/** MA-DH:
	 * 1. Alice computes (c, d) := Com_pk(ka) for ka = g^a, a = random 
	 *    and sends (ida, c) to Bob.
	 * 2. Bob computes kb = g^b for random b and sends (idb, kb) to Alice.
	 * 3. Alice sends d to Bob, who computes ka = Open_pk(c, d) and halts if 
	 *    ka = empty.
     * Both parties compute sid = (ida, idb) and oob = h(sid, ka, kb) from the 
     * received messages.
	 * 4. Both parties accept key = (g^a)^b = (g^b)^a iff the l-bit test 
	 *    values ooba and oobb coincide.
     * 
     * Specification: h is a keyed hash function with sub-keys ka, kb of G 
     * where G = g is a q element Decisional Diffie-Hellman group; G is a 
     * message space of commitment scheme. Public parameters pk and G are 
     * fixed and distributed by a trusted authority. Device identifiers ida 
     * and idb must be unique in time, for example, a device address followed 
     * by a session counter.
     * 
     * In this implementation, Alice is the client and Bob the server. This 
     * protocol is only assumed to be secure for a <b>bidirectional and
     * authentic</b> out-of-band channel.
	 */
    protected void performAuthenticationProtocol(boolean serverSide) {
    	SimpleKeyAgreement ka = null;
        String inOrOut, serverToClient, clientToServer, remoteAddr=null;
        int totalTransferTime=0, totalCryptoTime=0;
        long timestamp=0;
        
        try {
			remoteAddr = connection.getRemoteAddress().toString();
		} catch (IOException e1) {
			logger.error("Can not get address of remote. This should not happen!");
		}

        if (logger.isDebugEnabled()) {
        	logger.debug("Starting authentication protocol as " + (serverSide ? "server" : "client"));
        	logger.debug("Remote is " + remoteAddr + ", with timeout " + timeoutMs + "ms");
        }

        if (serverSide) {
        	inOrOut = "Incoming";
        	serverToClient = "sent";
        	clientToServer = "received";
        } else {
        	inOrOut = "Outgoing";
        	serverToClient = "received";
        	clientToServer = "sent";
        }
        
        if (logger.isDebugEnabled())
        	logger.debug(inOrOut + " connection to authentication service with " + remoteAddr);
        
        SafetyBeltTimer timer = null;
        try
        {
        	fromRemote = connection.getInputStream();
            // this enables auto-flush
            toRemote = new OutputStreamWriter(connection.getOutputStream());

            // now that we have the InputStream, bind our timer to it
            if (timeoutMs > 0)
            	timer = new SafetyBeltTimer(timeoutMs, fromRemote);

            if (serverSide) {
            	println(Protocol_Hello);
            }
            else {
                String msg = readLine();
                if (!msg.equals(Protocol_Hello)) {
                	raiseAuthenticationFailureEvent(connection, null, "Protocol error: did not get greeting from server");
                    shutdownConnectionCleanly();
                    return;
                }
        	}
            raiseAuthenticationProgressEvent(connection, 1, AuthenticationStages, inOrOut + " authentication connection, " + serverToClient + " greeting");

           	timestamp = System.currentTimeMillis();
           	
    		/* Both sides add a random nonce to refer to this specific session
    		 * to prevent two overlapping protocol runs with the same ida and
    		 * idb.
    		 */
            SecureRandom r = new SecureRandom();
            byte[] nonce = new byte[NonceByteLength];
            r.nextBytes(nonce);
            // TODO: we should really add our own address to the ID!
            String myIdStr = new String(Hex.encodeHex(nonce));

            byte[] myPubKey = null, remotePubKey = null, 
            	remoteCommitment = null, remoteId = null;
            if (!serverSide) {
            	// step 1: Alice computes her public key and sends the commitment
            	ka = new SimpleKeyAgreement(useJSSE);
            	myPubKey = ka.getPublicKey();
            	String commitment = new String(Hex.encodeHex(commitment(myPubKey)));
               	totalCryptoTime += System.currentTimeMillis()-timestamp;
               	timestamp = System.currentTimeMillis();
            	println(Protocol_AuthenticationRequest + ProtocolTypeMaDH + 
            			" " + myIdStr + " " + commitment +
            			(optionalParameter != null ? " " + 
            			 Protocol_AuthenticationRequest_Param + " " + 
            			 optionalParameter : ""));
               	totalTransferTime += System.currentTimeMillis()-timestamp;
            }
            else {
            	// step 1, part 2: Bob receives Alice's commitment
            	String expectedMsg = Protocol_AuthenticationRequest + 
   			 		ProtocolTypeMaDH;
            	String line = getLine(expectedMsg, connection, true);
            	Object[] parms = parseLine(line, expectedMsg, 
            			new boolean[] {true, true, false, false}, 
            			new String[] {null, null, Protocol_AuthenticationRequest_Param, null}, 
            			2, connection);
            	if (parms == null) {
            		shutdownConnectionCleanly();
                    return;
            	}
            		
            	// first part is the remote ID part
                remoteId = (byte[]) parms[0];
                // next part is the commitment, which may be the last one
               	remoteCommitment = (byte[]) parms[1];
                // additional parameter from the remote?
               	optionalParameter = (String) parms[3];
               	if (optionalParameter != null && logger.isDebugEnabled())
               		logger.debug("Received optional parameter from client: '" + optionalParameter + "'.");
               	totalTransferTime += System.currentTimeMillis()-timestamp;
            }
            raiseAuthenticationProgressEvent(connection, 2, AuthenticationStages, inOrOut + " authentication connection, " + clientToServer + " public key");

           	timestamp = System.currentTimeMillis();
            if (serverSide) {
            	// step 2: Bob sends his public key and ID
                // for performance reasons: only now start the DH phase
            	ka = new SimpleKeyAgreement(useJSSE);
            	myPubKey = ka.getPublicKey();
            	String myPubKeyStr = new String(Hex.encodeHex(myPubKey));
               	totalCryptoTime += System.currentTimeMillis()-timestamp;
               	timestamp = System.currentTimeMillis();
            	println(Protocol_AuthenticationAcknowledge + myIdStr + " " + myPubKeyStr);
               	totalTransferTime += System.currentTimeMillis()-timestamp;
            }
            else {
            	// step 2, part 2: Alice receives Bob's ID and public key
            	String expectedMsg = Protocol_AuthenticationAcknowledge;
            	String line = getLine(expectedMsg, connection, false);
            	Object[] parms = parseLine(line, expectedMsg, 
            			new boolean[] {true, true}, null, 2, connection);
            	if (parms == null) {
            		shutdownConnectionCleanly();
                    return;
            	}
            	
            	// first part is the remote ID part
               	remoteId = (byte[]) parms[0];
               	// second part is the remote public key
               	remotePubKey = (byte[]) parms[1];
                if (remotePubKey.length < 128) {
                    logger.warn("Protocol error: could not parse public key, expected 128 Bytes hex-encoded.");
                    println("Protocol error: could not parse public key, expected 128 Bytes hex-encoded.");
                    raiseAuthenticationFailureEvent(connection, null, "Protocol error: remote key too short (only " + remotePubKey.length + " bytes instead of 128)");
                    shutdownConnectionCleanly();
                    return;
                }
                totalTransferTime += System.currentTimeMillis()-timestamp;
            }
            raiseAuthenticationProgressEvent(connection, 3, AuthenticationStages, inOrOut + " authentication connection, " + serverToClient + " public key");

           	timestamp = System.currentTimeMillis();
            if (!serverSide) {
            	// step 3: Alice sends her public key
            	String myPubKeyStr = new String(Hex.encodeHex(myPubKey));
            	println(Protocol_AuthenticationAcknowledge2 + myPubKeyStr);
               	totalTransferTime += System.currentTimeMillis()-timestamp;            	
            }
            else {
            	// step 3, part 2: Bob receives Alice's public key
            	String expectedMsg = Protocol_AuthenticationAcknowledge2;
            	String line = getLine(expectedMsg, connection, false);
            	Object[] parms = parseLine(line, expectedMsg, 
            			new boolean[] {true}, null, 1, connection);
            	if (parms == null) {
            		shutdownConnectionCleanly();
                    return;
            	}
            	
            	// first and only part is the remote public key
               	remotePubKey = (byte[]) parms[0];
                if (remotePubKey.length < 128) {
                    logger.warn("Protocol error: could not parse public key, expected 128 Bytes hex-encoded.");
                    println("Protocol error: could not parse public key, expected 128 Bytes hex-encoded.");
                    raiseAuthenticationFailureEvent(connection, null, "Protocol error: remote key too short (only " + remotePubKey.length + " bytes instead of 128)");
                    shutdownConnectionCleanly();
                    return;
                }
                // and check that it matches the commitment
                totalTransferTime += System.currentTimeMillis()-timestamp;
               	timestamp = System.currentTimeMillis();
               	byte[] remoteCommitmentExpected = commitment(remotePubKey);
               	// grml, no java.util.Arrays class in J2ME - this simply sucks
               	for (int i=0; i<remoteCommitment.length && i<remoteCommitmentExpected.length; i++) {
                    if (remoteCommitment[i] != remoteCommitmentExpected[i]) {
                        logger.warn("Protocol error: remote commitment does not match public key");
                        println("Protocol error: remote commitment does not match public key");
                        raiseAuthenticationFailureEvent(connection, null, "Protocol error: remote commitment does not match public key");
                        shutdownConnectionCleanly();
                        return;
                    }
               	}
                totalCryptoTime += System.currentTimeMillis()-timestamp;
            }
            // step 3, part 3: Alice and Bob compute the out-of-band message
           	timestamp = System.currentTimeMillis();
           	// TODO: might want to add local and remote addresses
            byte[] oobInput = new byte[2*NonceByteLength +
                                       (presharedShortSecret != null ? 
                                               presharedShortSecret.length : 0)]; 
            byte[] oobKey = new byte[myPubKey.length + remotePubKey.length];
            // order: first client, then server
            if (!serverSide) {
            	System.arraycopy(nonce, 0, oobInput, 0, NonceByteLength);
            	System.arraycopy(remoteId, 0, oobInput, NonceByteLength, NonceByteLength);
            	System.arraycopy(myPubKey, 0, oobKey, 0, myPubKey.length);
            	System.arraycopy(remotePubKey, 0, oobKey, myPubKey.length, remotePubKey.length);
            }
            else {
            	System.arraycopy(remoteId, 0, oobInput, 0, NonceByteLength);
            	System.arraycopy(nonce, 0, oobInput, NonceByteLength, NonceByteLength);
            	System.arraycopy(remotePubKey, 0, oobKey, 0, remotePubKey.length);
            	System.arraycopy(myPubKey, 0, oobKey, remotePubKey.length, myPubKey.length);
            }
            byte[] oobMsg;

            // transfer: one device sends oobMsg to the other, the latter compares
            //           important: the used must press "yes" on the former if and only if the latter accepted (1-bit OOB)
            // comparison: user needs to enter yes/no on both sides after being shown oobMsg somehow
            // input: additional steps required
            // TODO: need to distinguish between three input cases:
            // a) *short* *secret* message that can be pre-entered
            // b) *short* non-secret message that needs to be input after the protocol has started!
            // c) long non-secret but authentic message that can be used for pre-authentication
            if (presharedShortSecret != null) {
            	logger.info("Preshared short secret is available, entering this protocol path on " 
            			+ (serverSide ? "server" : "client"));
            	// case 1: MANA III assuming the user input to be secret, but it
            	// may have already been entered before even starting the protocol
            	// instead of transmitting/comparing oobMsg, add the short secret to it 
            	// and make it a commitment scheme
            	/* A generates random K1, computes M1 = HMAC_K1 (Ia | DH-key | R) where
 * R is the user input data. B does the same, they swap M1 and M2 and _then_ swap K1 and K2
 * assumption: R remains secret */
            	System.arraycopy(presharedShortSecret, 0, oobInput, 
            			NonceByteLength*2, presharedShortSecret.length);

            	// another two-round commitment scheme, but now using a HMAC keyed with a random key
            	// 1. send HMAC_K1(oobInput)
                byte[] myK = new byte[NonceByteLength];
                r.nextBytes(myK);
                byte[] myM = keyedHash(oobInput, myK);
                totalCryptoTime += System.currentTimeMillis()-timestamp;
               	timestamp = System.currentTimeMillis();

                String myMStr = new String(Hex.encodeHex(myM));
                println(Protocol_AuthenticationInputCommit + myMStr);

                // 2. receive M2
            	String line = getLine(Protocol_AuthenticationInputCommit, connection, false);
            	Object[] parms = parseLine(line, Protocol_AuthenticationInputCommit, 
            			new boolean[] {true}, null, 1, connection);
            	if (parms == null) {
                    logger.warn("Protocol error: remote did not send commitment for short shared secret.");
                    println("Protocol error: remote did not send input commitment for short shared secret.");
                    raiseAuthenticationFailureEvent(connection, null, "Protocol error: no remote commitment");
            		shutdownConnectionCleanly();
                    return;
            	}
            	byte[] remoteM = (byte[]) parms[0];
                if (remoteM.length < 16) {
                    logger.warn("Protocol error: could not parse commitment for short shared secret, expected 128 Bits hex-encoded.");
                    println("Protocol error: could not parse input commitment for short shared secret, expected 128 Bits hex-encoded.");
                    raiseAuthenticationFailureEvent(connection, null, "Protocol error: remote commitment too short (only " + remotePubKey.length + " bytes instead of 16)");
                    shutdownConnectionCleanly();
                    return;
                }
                
                // if we have an input case and R1/2 are _not_ secret, then they must 
                // be input to the respective other sides exactly here in the protocol, not
                // earlier and not later
                // it is important that R1/2 is not made available to an attacker 
                // before the commitments M1/M2 have been exchanged because
                // otherwise it could create valid commitments with different
                // public keys (and different K1/K2, as long as R is known)
                // need to block at this stage until both devices received R
               	
               	// TODO for non-secret short input (i.e. user-generated keys):
                // this case will only work in Hollywood mode
               	// byte[] remoteShortSecret = oobChannel.receive();

                // 3. send K1
                String myKStr = new String(Hex.encodeHex(myK));
                println(Protocol_AuthenticationInputOpen + myKStr);

                // 4. receive K2
            	line = getLine(Protocol_AuthenticationInputOpen, connection, false);
            	parms = parseLine(line, Protocol_AuthenticationInputOpen, 
            			new boolean[] {true}, null, 1, connection);
            	if (parms == null) {
            		shutdownConnectionCleanly();
                    return;
            	}
            	byte[] remoteK = (byte[]) parms[0];
                if (remoteK.length < 16) {
                    logger.warn("Protocol error: could not parse remote K, expected 128 Bits hex-encoded.");
                    println("Protocol error: could not parse remote K, expected 128 Bits hex-encoded.");
                    raiseAuthenticationFailureEvent(connection, null, "Protocol error: remote K too short (only " + remotePubKey.length + " bytes instead of 16)");
                    shutdownConnectionCleanly();
                    return;
                }
                totalTransferTime += System.currentTimeMillis()-timestamp;
               	timestamp = System.currentTimeMillis();

                // 5. compare M1 and M2
                byte[] remoteMExpected = keyedHash(oobInput, remoteK);
               	// grml, no java.util.Arrays class in J2ME - this simply sucks
               	for (int i=0; i<remoteM.length && i<remoteMExpected.length; i++) {
                    if (remoteM[i] != remoteMExpected[i]) {
                        logger.warn("Protocol error: remote input commitment does not match");
                        println("Protocol error: remote input commitment does not match");
                        raiseAuthenticationFailureEvent(connection, null, "Protocol error: remote input commitment does not match");
                        shutdownConnectionCleanly();
                        return;
                    }
               	}
                totalCryptoTime += System.currentTimeMillis()-timestamp;

                // already authenticated!
                oobMsg = null;
            }
            else {
                // TODO: define asymmetric case from Wong/Stajano page 11
                // need to be clear which messages may be omitted (none for consistency?)
                // and which user interaction is required -> the ACK, but on which device?
                // personal device needs to verify, so "service" device needs to
                // send commitment and R
            	
            	// transfer or comparison case (depends on OOB channel)
                oobMsg = keyedHash(oobInput, oobKey);
            }
            totalCryptoTime += System.currentTimeMillis()-timestamp;
            raiseAuthenticationProgressEvent(connection, 4, AuthenticationStages, inOrOut + " authentication connection, commitment");

            // final step: finish DH computation, but _only use keys after OOB message has been accepted by both sides_
            // TODO: in Hollywood mode, don't do this until we accept
            
            // in PlainObject mode, generate the final session key and the OOB string and forward both
            timestamp = System.currentTimeMillis();
            ka.addRemotePublicKey(remotePubKey);
            Object sessKey = ka.getSessionKey();
            Object authKey = oobMsg;
           	totalCryptoTime += System.currentTimeMillis()-timestamp;
            raiseAuthenticationProgressEvent(connection, 5, AuthenticationStages, inOrOut + " authentication connection, computed shared secret");

            // the authentication success event sent here is just an array of two keys
            if (keepConnected) {
            	logger.debug("Not closing socket as requested, but passing it to the success event.");
            	// don't shut down the streams because this effectively shuts down the connection
            	// but make sure that the last message has been sent successfully
            	toRemote.flush();
            	raiseAuthenticationSuccessEvent(connection, new Object[] {sessKey, authKey,
            			optionalParameter, connection});
            }
            else {
            	raiseAuthenticationSuccessEvent(connection, new Object[] {sessKey, authKey,
            			optionalParameter });
				logger.info("Closing channel that has been used for key agreement");
            	shutdownConnectionCleanly();
            }
            
            	logger.warn("Key transfers took " + totalTransferTime + 
            			"ms, crypto took " + totalCryptoTime + "ms");
        }
        catch (InternalApplicationException e)
        {
            logger.error("Caught exception during host protocol run, aborting: " + e);
            // also communicate any application exception to interested
			// listeners
            raiseAuthenticationFailureEvent(connection, e, null);
            shutdownConnectionCleanly();
        }
        catch (IOException e)
        {
            logger.error("Caught exception during host protocol run, aborting: " + e);
            // even if we ignore the exception and not treat it as an error
			// case, report it to listeners
            // so that they can clean up their state of this authentication
			// (identified by the remote)
            raiseAuthenticationFailureEvent(connection, null, "Client closed connection unexpectedly or hit timeout");
            shutdownConnectionCleanly();
        }
        catch (Exception e)
        {
            logger.fatal("UNEXPECTED EXCEPTION: " + e);
            e.printStackTrace();
            shutdownConnectionCleanly();
        }
        finally {
            if (ka != null)
                ka.wipe();
            // this is not strictly necessary, but clean up properly
            if (timer != null)
            	timer.stop();
            if (logger.isDebugEnabled())
            	logger.debug("Ended " + inOrOut + " authentication connection with " + remoteAddr);
        }
    }
	
    
    /** Hack to just allow one method to be called asynchronously while still having access to the outer class. */
    private abstract class AsynchronousCallHelper implements Runnable {
    		protected HostProtocolHandler outer;
    	
    		protected AsynchronousCallHelper(HostProtocolHandler outer) {
    			this.outer = outer;
    		}
    }

    /** Starts a background thread for handling an incoming authentication
	 * request. Should only be called by HostServerSocket after accepting a new
	 * connection.
	 * @param asynchronousCall When set to true, this method will perform the
	 *                         protocol asynchronously an return immediately to the
	 *                         caller (firing events later on from the other thread). 
	 *                         When set to false, this method will block until the 
	 *                         authentication protocol has been completed (events will 
	 *                         be fired from within the thread of the caller)
	 */
	public void startIncomingAuthenticationThread(boolean asynchronousCall) {
		logger.debug("Starting incoming authentication thread handler");
		/* The very first thing to do is to fire off the respective started event.
		 * This is done even before starting a potential background thread 
		 * (and thus not in performAuthenticationProtocol, but with code 
		 * duplication here and below) to minimize potential for race 
		 * conditions on application level.
		 */
		// This will e.g. trigger the creation of a State object in KeyManager, when used.
		if (!raiseAuthenticationStartedEvent(connection)) {
			logger.warn("Some AuthenticationStarted event handler vetoed the incoming authentication request from " +
					connection + ". Aborting it now, not starting authentication protocol");
		}
		
		if (asynchronousCall) {
			new Thread(new AsynchronousCallHelper(this) {
				public void run() {
					outer.performAuthenticationProtocol(true);
				}
			}).start();
			logger.debug("Started incoming authentication thread handler");
		}
		else {
			performAuthenticationProtocol(true);
			logger.debug("Exiting incoming authentication thread handler");
		}
	}
	
    /** Outgoing authentication connections are done asynchronously just like the
	 * incoming connections. This method starts a new thread that tries to
	 * authenticate with the host given as remote. Callers need to subscribe to
	 * the Authentication* events to get notifications of authentication
	 * success, failure and progress.
	 * When presharedShortSecret is set to null, the protocol will use 
	 * <b>transfer</b> or <b>verification</b> mode. When it is set to some
	 * value, <b>secret pre-input</b> mode is used.
	 * 
	 * @param remote
	 *            The remote connection to use for key agreement.
	 * @param eventHandler
	 *            The event handler that should be notified of authentication
	 *            events. Can be null (in which case no events are sent). If not
	 *            null, it will be registered with a new HostProtocolHandler
	 *            object before starting the authentication protocol so that it
	 *            is guaranteed that all events are posted to the event handler.
	 * @param presharedShortSecret
	 * 			  If a user has already entered the same short <b>secret</b> 
	 *            key into both sides, it may be passed in this parameter to
	 *            avoid further authentication via out-of-band channel. It is
	 *            important this this <b>must</b> remain secret until the 
	 *            protocol finishes and that it <b>must not</b> be re-used.
	 * @param timeoutMs
	 * 			  The maximum duration in milliseconds that this authentication
	 * 			  protocol may take before it will abort with an AuthenticationFailed
	 * 			  exception. Set to -1 to disable the timeout.
	 * @param keepConnected
	 *            When set to true, the connection created in this method is not
	 *            closed but passed to the authentation success event for
	 *            further reuse.
	 * @param optionalParameter
	 *            If not null, this string will be passed to the server in the
	 *            authentication request message. Both the server and the client 
	 *            will then subsequently forward this string in their 
	 *            authentication success message. This parameter <b>must</b> be
	 *            encoded in 7-bit ASCII and <b>must not</b> contain spaces.
	 *            
	 * @param useJSSE If set to true, the JSSE API with the default JCE provider of the JVM will be used
	 *                for cryptographic operations. If set to false, an internal copy of the Bouncycastle
	 *                Lightweight API classes will be used.
	 */
    static public void startAuthenticationWith(RemoteConnection remote,
			AuthenticationProgressHandler eventHandler,
			byte[] presharedShortSecret,
			int timeoutMs,
			boolean keepConnected, String optionalParameter,
			boolean useJSSE) throws IOException {
    	if (logger.isInfoEnabled())
    		logger.info("Starting authentication with " + 
    				remote.getRemoteAddress() + "'/" + remote.getRemoteName() + "'");

		HostProtocolHandler tmpProtocolHandler = new HostProtocolHandler(remote, presharedShortSecret,
				timeoutMs, keepConnected, useJSSE);
		tmpProtocolHandler.useJSSE = useJSSE;
		if (eventHandler != null)
			tmpProtocolHandler.addAuthenticationProgressHandler(eventHandler);
		tmpProtocolHandler.optionalParameter = optionalParameter;
		/* The very first thing to do is to fire off the respective started event.
		 * This is done even before starting a potential background thread 
		 * (and thus not in performAuthenticationProtocol, but with code 
		 * duplication here and above) to minimize potential for race 
		 * conditions on application level.
		 */
		// This will e.g. trigger the creation of a State object in KeyManager, when used.
		if (!tmpProtocolHandler.raiseAuthenticationStartedEvent(remote)) {
			logger.warn("Some AuthenticationStarted event handler vetoed the outgoing authentication request to " +
					remote + ". Aborting it now, not starting authentication protocol");
		}

		// start the authentication protocol in the background
		new Thread(tmpProtocolHandler.new AsynchronousCallHelper(
				tmpProtocolHandler) {
			public void run() {
				outer.performAuthenticationProtocol(false);
			}
		}).start();
    }

    /** This is a convenience wrapper setting presharedShortSecret to null and
     * thus starting the protocol in <b>transfer</b> or <b>verification</b> mode.
     * @see startAuthenticationWith
     */
    static public void startAuthenticationWith(RemoteConnection remote,
			AuthenticationProgressHandler eventHandler,
			int timeoutMs,
			boolean keepConnected, String optionalParameter,
			boolean useJSSE) throws IOException {
    	startAuthenticationWith(remote, eventHandler, null, timeoutMs,
    			keepConnected, optionalParameter, useJSSE);
    }
}
